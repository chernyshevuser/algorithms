--УСЛОВИЕ ЗАДАЧИ--
 Имеется неориентированный граф. Необходимо найти его максимальное остовое дерево. Если такое дерево существует,
 необходимо вывести его вес, иначе фразу "Oops, i did it again".  В графе могут быть петли и кратные ребра.
 Граф может оказаться несвязным.

--ФОРМАТ ВВОДА ДАННЫХ--
 В первой строке дано количество вершин n и ребер m графа
 В каждой из следующих m строк заданы рёбра в виде троек чисел u, v, w. u и v — вершины, которые соединяет это ребро.
 w — его вес

--ПРИНЦИП РАБОТЫ--
 Для нахождения наибольшего остового дерева в графе реализован алгоритм Прима с использованием приоритетной кучи.
 Создается приоритетная куча, поддерживающая максимум из всех возможных ребер, идущих из уже отобранного остова.
 Изначально куча пуста, и на первом шаге в нее добавляются все ребра, идущие из вершины с номером 1, сама вершина
 помечается как испольуемая. Затем из кучи выбирается и удаляется ребро,имеющее наибольший вес.
 Соответствующая вершина добавляется в список используемых, в кучу добавляются все ребра, идущие из этой вершины,
 за исключением ребер, связывающих текущую вершину с одной из уже используемых вершин. Затем действия повторяются.
 Процесс завершается, когда в куче либо не осталось ребер, либо количество используемых вершин совпадает с
 общим числом вершин в графе.
 Выбор начальной вершины не важен, потому что в любом случае эту вершину придется включить в остовое дерево по
 ребру с наибольшим весом. В случае, если у вершины нет ни одного ребра, изначальный граф не является связным,
 следовательно, остовое дерево получить невозможно.

--ВРЕМЕННАЯ СЛОЖНОСТЬ--
 Пусть V - количество вершин в графе, E - количество ребер.
 Цикл while в функции GetMaxSpanningTreeWeight повторится не более V раз.
 Суммарно в кучу будет добавлено и извлечено не более E ребер, где одно действие стоит log(k), где k - текущее
 количество элементов в куче. Сложность этой операции в среднем будет составлять (log(1) + log(E)) / E. Поэтому
 общая сложность E операций составит E  * log(E) / E = log(E)
 Таким образом, общая сложность составит O(V * log(E))

--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--
 Хранение ребер в графе использует O(E + V) памяти, потому что граф представлен в виде vector<vector<EdgePart>>:
 сначала выделяется vector размера V, а затем будет добавлено не более 2 * E ребер
 Куча требует еще O(E) памяти: в куче хранится не более E ребер
 Таким образом, общая сложность составит O(E + V)
