--УСЛОВИЕ ЗАДАЧИ--
Необходимо написать реализацию хеш-таблицы, чтобы хранить в ней базу данных с зарплатами сотрудников.
Хеш-таблица должна поддерживать следующие операции:
1) put key value —– добавление пары ключ-значение. Если заданный ключ уже есть в таблице, то
соответствующее ему значение обновляется.
2) get key –— получение значения по ключу. Если ключа нет в таблице, то вывести «None». Иначе вывести
найденное значение.
3) delete key –— удаление ключа из таблицы. Если такого ключа нет, то вывести «None», иначе вывести
хранимое по данному ключу значение и удалить ключ.
В таблице хранятся уникальные ключи.
Требования к реализации:
Число хранимых в таблице ключей не превосходит 1e5.
Разрешать коллизии следует с помощью метода цепочек или с помощью открытой адресации.
Все операции должны выполняться за O(1) в среднем.
Поддерживать рехеширование и масштабирование хеш-таблицы не требуется.
Ключи и значения, id сотрудников и их зарплата, – целые числа. Поддерживать произвольные хешируемые
типы не требуется.


--ФОРМАТ ВВОДА--
В первой строке задается общее число запросов к таблице n.
В следующих n строках записаны запросы, которые бывают трех видов – get, put, delete – как описано в условии.
Все ключи и значения — целые неотрицательные числа, не превосходящие 1e9.


--ПРИНЦИП РАБОТЫ--
 Хеш-таблица реализована метода цепочек. Информация об id работников и их зарплатах хранится в векторе достаточно
 большого размера, состоящего из ссылок на односвязные списки, в которых и хранится информация о человеке.
 Необходимые методы реализованы следующим образом:
 метод put(id, salary): сначала вычисляется хеш по id, затем по хешу находится соответствующий список,
 информация о работнике обновляется/добавляется в начало списка
 метод get(id): по id вычисляется хэш, по хешу находим список, далее либо выводим зарплату работника, если он есть
 в списке, либо выводим сообщение об ошибке None
 метод delete(id): вычисляется хеш, затем происходит удаление элемента из списка. Если работник находился в списке,
 выводится его зарплата, иначе сообщение об ошибке None


--ВРЕМЕННАЯ СЛОЖНОСТЬ--
 Пусть n - кол-во работников.
 Размер вектора я взял сопоставимым с максимальным кол-вом человек, которые могут находиться в списке
 (в моей реализации величины совпадают).

 Хороший случай выполнения одной операции(коллизии отсутствуют):
 getHash(...) - O(1)
 get(...) := getValue(...) - O(1), т.к. информация находится в начале списка
 put(...) := putValue(...) - O(1), т.к. вставка всегда происходит в начало списка, а коллизий и, следовательно,
 проверок нет
 delete(...) := deleteValue(...) - O(1) аналогично

 Плохой случай выполнения одной операции(у всех работников одинаковый по хешу id):
 getHash(...) - O(1)
 get(...) := getValue(...) - O(n), т.к. для проверки наличия необходимо обойти всех работников
 put(...) := putValue(...) - O(n), т.к. необходима проверка наличия информации о работнике
 delete(...) := deleteValue(...) - O(n), т.к. необходима проверка наличия информации о работнике

 Средний случай(id всех работников равномерно попадают в вектор) примерно совпадает с хорошим случаем.
 Если это не так, можно увеличить размер вектора и использовать более хитрую функцию хеширования

 Таким образом, лучшая сложность составит O(n), худшая - O(n^2)

--ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ--
 Под исходный массив выделяется порядка O(n) памяти по причине выбора такого размера для уменьшения кол-ва коллизий.
 В лучшем случае, когда коллизий нет, общая пространствнная сложность будет составлять O(n), потому что память на
 n человек заранее выдлена(O(n) + O(n) = O(n)). В худшем случае, когда у всех людей одинаковый хеш, придется выделить
 еще O(n) памяти на один список, что ассимптотически дает все равно O(n)
